<!DOCTYPE html>
<!--
/*
 * INTER-Mediator Ver.@@@@2@@@@ Released @@@@1@@@@
 *
 *   by Masayuki Nii  msyk@msyk.net Copyright (c) 2014 Masayuki Nii, All rights reserved.
 *
 *   This project started at the end of 2009.
 *   INTER-Mediator is supplied under MIT License.
 */
-->
<html>
<head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <link href="../pagestyle.css" rel="stylesheet" media="screen"/>
    <link rel="shortcut icon" href="../im-icon.png" type="image/png"/>
    <link rel="icon" href="../im-icon.png" type="image/png"/>
    <title>INTER-Mediator</title>
    <script type="text/javascript" language="JavaScript">
        var htmlDocumentModDate = document.lastModified;
    </script>
    <script type="text/javascript" language="JavaScript" src="../pagebuilder.js"></script>
    <script type="text/javascript" language="JavaScript" src="../files/jquery-1.10.2.min.js"></script>
</head>
<body>
<div id="page_header"></div>
<div id="navigation"></div>
<div id="page_contents">
<h2>INTER-MediatorによるWebアプリケーションの概要</h2>

<p>
    データベースにMySQLなど、PHPのPDOに対応したものを利用することを想定します。データベースが稼働しており、INTER-Mediatorがインストールされている状況であるとします。このとき、以下の2つのファイルを作成します。いずれのファイルについても原則はどこにあってもかまいませんが、定義ファイルはデータベースサーバと同一のコンピュータにあるようにするのが一般的でしょう。
</p>
<ul>
    <li>ブラウザにロードするHTMLファイル（「ページファイル」と名付けます）</li>
    <li>データベース接続など設定を記述したPHPファイル（「定義ファイル」と名付けます</li>
</ul>
<h3>定義ファイルの記述</h3>

<p>
    定義ファイルは、PHPのファイルにします。したがって、PHPの処理が可能なサーバに配置しないといけません。以下のように、INTER-Mediator.phpを読み込み、IM_Entry関数をコールします。この関数の引数の指定方法は、後で記述します。
</p>

<div class="code"><pre><code>&lt;?php require_once ( 'INTER-Mediator/INTER-Mediator.php');
    IM_Entry( $tableDefs, $optionDefs, $dbDefs, true ); ?&gt;</code></pre>
</div>
<p>
    サンプルで言えば、sample_form_FMS_include.phpや、sample_form_MySQL_include.phpのファイルが、定義ファイルに相当します。
</p>

<h3>ページファイルの記述</h3>

<p>
    ページファイルでは、定義ファイルを、ヘッダエリアのscriptタグで読み込みます。定義ファイルは、JavaScriptのソースを返します。そして、典型的な方法として、ページを開いたときにデータベースのデータを取り出すという流れがあるかと思います。その場合、以下のように、bodyタグのonload属性に、NTERMediator.construct(true)というJavaScriptの呼び出しを記述します。基本的にはこれで、INTER-Mediatorが働き始めます。NTERMediator.construct(true)は、たとえばボタンをクリックして呼び出すという方法も取る事ができます。
</p>

<div class="code"><pre><code>&lt;html&gt;
    &lt;head&gt;
    &lt;script src="sample_form_MySQL_include.php"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body onload="INTERMediator.construct(true)"&gt;
    :
    &lt;td&gt;&lt;input type="text" class="IM[contact@datetime]"/&gt;&lt;/td&gt;</code></pre>
</div>
<p>
    以上の準備をすれば、ページファイル内のタグのtitle属性やclass属性に記述を加えることで、そのタグの値や他の属性に対してデータベースから取り出したデータが設定されることになります。title属性の場合は「contact@datetime」、class属性の場合はIMと大カッコでかこって「IM[contact@datetime]」といった記述を行います。この記述を「ターゲット指定」と呼ぶ事にします。また、ターゲット指定のあるタグのことを「リンクノード」と呼びます。ターゲット指定の詳細は、後で説明をします。
</p>

<p>
    サンプルで言えば、sample_form_FMS.htmlや、sample_form_MySQL.htmlのファイルが、ページファイルに相当します。
</p>

<h3>ページの表示</h3>

<p>
    以上のような準備をした上で、ブラウザより、ページファイルにアクセスをします。そうすれば、リンクノードのターゲット指定や、定義ファイルでの指定に基づいて、データベースのデータを取り込んでページを構成します。データベースの内容を表示しますが、複数のレコードがあれば繰り返して一覧表示などを行います。
</p>

<h2>定義ファイルでのIM_Entry関数の引数</h2>

<p>定義ファイルに記述するIM_Entry関数の引数に、データベースに関する情報を与えておきます。4つの引数があり、うち3つは配列を指定します。配列の内容を記載します。以下の表で、次元の列にキーワードがあれば、「 'キーワード' =>
    '値' 」で該当する値を与えます。次元が「（なし）」というのは、その次元では、単に要素が並ぶということを意味します。サンプルファイルの例などを見ながら解読してください。</p>

<h3>第1引数、テーブルとそれに関連した属性</h3>

<p>
    テーブルと、テーブル間を関連づけるフィールドを指定します。この引数の第2次元にまとめられた1つの配列の設定を「コンテキスト定義」と呼ぶことにします。つまり、name、keyなどのキーを持った連想配列の1つ1つがコンテキスト定義です。もちろん、コンテキスト定義は複数を定義することが可能です。ここでのnameが、ターゲット指定のテーブル名で使用します。テーブル間の結合における相手のテーブル名がないと思われるかもしれませんが、相手のテーブル名は、ページファイル側の記述で自動的に決まってきます。</p>

<div class="table">
<table>
<tr>
    <th colspan="4">
        配列指定
    </th>
    <th rowspan="2">
        値
    </th>
</tr>
<tr>
    <th width="60">
        第1次元
    </th>
    <th width="160">
        第2次元
    </th>
    <th width="90">
        第3次元
    </th>
    <th width="120">
        第4次元
    </th>
</tr>
<tr>
    <td rowspan="60">
        (なし)
    </td>
    <td>
        'name'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        テーブル名[必須]。'view'がなければすべての処理を適用する「テーブル名」、'view'があれば書き込みや更新処理のときの「テーブル名」
    </td>
</tr>
<tr>
    <td>
        'table'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        指定すると更新時の「テーブル名」に使用される。指定しないと、nameで指定した名前のテーブルに書き込む
    </td>
</tr>
<tr>
    <td>
        'view'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        指定すると読み込みのときの「テーブル名」に使用される。指定しないと、nameで指定した名前のテーブルから読み込む
    </td>
</tr>
<tr>
    <td>
        'records'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        1ページに何レコード分表示するか。最初のテーブルの設定のみ有効。省略すると大きな数値
    </td>
</tr>
<tr>
    <td>
        'maxrecords'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        INTERMediator.pagedSizeの値を調整することで1ページ内の表示レコード数を指定できる
    </td>
</tr>
<tr>
    <td>
        'paging'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>recordsで指定したレコード数ずつ表示するとき、前後のページに移動するナビゲーションを表示する場合、trueを指定する。既定値はfalse</td>
</tr>
<tr>
    <td>
        'key'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        主キーフィールド名
    </td>
</tr>
<tr>
    <td>
        'cache'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        trueを指定するとキャッシュが機能する（Ver.3.0より順次組み込みのため、機能制限に注意）
    </td>
<tr>
</tr>
<td>
    'sequence'
</td>
<td>
</td>
<td>
</td>
<td>
    PostgreSQLにおいて、レコード追加を行うためには、シーケンスを利用してキーフィールドに連番を設定する必要がある。そのシーケンス名をここで指定をする。
</td>
</tr>
<tr>
    <td rowspan="4">
        'relation'
    </td>
    <td rowspan="4">
        (なし)
    </td>
    <td>
        'foreign-key'
    </td>
    <td>
        リレーションの外部キーフィールド名（この設定は事実上データ取り出し時のみ有効）
    </td>
</tr>
<tr>
    <td>
        'join-field'
    </td>
    <td>
        外部キーフィールドに対応するテーブル側の関連フィールド
    </td>
</tr>
<tr>
    <td>
        'operator'
    </td>
    <td>
        外部キーフィールドと対応するフィールドの比較演算子
    </td>
</tr>
<td>
    'portal'
</td>
<td>
    FileMaker Serverを利用しているときに、このコンテキストのデータを、親コンテキストのレイアウト上にあるポータルから取得する場合にtrueを値に指定する
</td>
</tr>
<tr>
    <td rowspan="3">
        'query'
    </td>
    <td rowspan="3">
        (なし)
    </td>
    <td>
        'field'
    </td>
    <td>
        検索条件のフィールド名（この設定はデータ取り出し時のみ有効）
    </td>
</tr>
<tr>
    <td>
        'value'
    </td>
    <td>
        検索値
    </td>
</tr>
<tr>
    <td>
        'operator'
    </td>
    <td>
        検索値の解釈
    </td>
</tr>
<tr>
    <td rowspan="2">
        'sort'
    </td>
    <td rowspan="2">
        (なし)
    </td>
    <td>
        'field'
    </td>
    <td>
        ソート条件のフィールド名（この設定はデータ取り出し時のみ有効）
    </td>
</tr>
<tr>
    <td>
        'direction'
    </td>
    <td>
        昇順か降順か
    </td>
</tr>
<tr>
    <td rowspan="2">
        'default-values'
    </td>
    <td rowspan="2">
        (なし)
    </td>
    <td>
        'field'
    </td>
    <td>
        新規レコード作成時の初期値指定のフィールド名
    </td>
</tr>
<tr>
    <td>
        'value'
    </td>
    <td>
        初期値
    </td>
</tr>
<tr>
    <td>
        'post-reconstruct'
    </td>
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>trueなら、入力型フォームにおいて、登録ボタンを押した後にページの再合成を行う。post-dismiss-messageが指定されていれば、4秒後待って再合成する。falseあるいは指定なしなら何もしない</td>
</tr>
<td>
    'post-dismiss-message'
</td>
</td>
<td>
</td>
<td>
</td>
<td>入力型フォームにおいて、登録ボタンを押した後に、ボタンを消してここに記述したメッセージの文字列を表示する。文字列はSPANタグでclass属性が「IM_POSTMESSAGE」となる。</td>
</tr>
<td>
    'post-move-url'
</td>
</td>
<td>
</td>
<td>
</td>
<td>入力型フォームにおいて、登録ボタンを押した後に、ここで指定したURLにページを移動させる。指定しない場合にはページ移動はない。post-dismiss-messageが指定されていれば、4秒後に移動する</td>
</tr>
<td>
    'repeat-control'
</td>
</td>
<td>
</td>
<td>
</td>
<td>
    繰り返し表示する部分に、レコードの追加や削除の機能を追加する。値には文字列として「insert」「insert-top」「delete」「confirm-insert」「confirm-insert-top」「confirm-delete」の文字で。confirmがあれば確認ダイアログが表示される。複数を指定する場合はそれぞれの文字列を空白で区切って書き並べる
</td>
</tr>
<tr>
    <td rowspan="3">
        'validation'
    </td>
    <td rowspan="3">
        (なし)
    </td>
    <td>
        'field'
    </td>
    <td>
        データ確認を行うフィールド名（バリデーションはVer.2.1以降で実装）
    </td>
</tr>
<tr>
    <td>
        'rule'
    </td>
    <td>
        確認処理。JavaScriptの式を記述する。コンポーネントの値は変数value、ノードへの参照は変数targetに入っているものとして、式を組み立てることができる。式の結果がtrueならそのまま処理を進めるが、falseならmessageの文字列をダイアログボックスで表示して、コンポーネントの値を元に戻す
    </td>
</tr>
<tr>
    <td>
        'message'
    </td>
    <td>
        正しくない場合に表示するメッセージ（ruleがfalseのときに表示される）
    </td>
</tr>
<tr>
    <td>'post-repeater'</td>
    <td></td>
    <td></td>
    <td>ページ合成時に1つのリピータの処理が終わった後に呼び出される関数名を記述する。その関数自体は、INTERMediatorOnPageオブジェクトのメソッドとして定義する。</td>
</tr>
<tr>
    <td>'post-enclosure'</td>
    <td></td>
    <td></td>
    <td>ページ合成時に1つのエンクロージャーの処理が終わった後に呼び出される関数名を記述する。その関数自体は、INTERMediatorOnPageオブジェクトのメソッドとして定義する。</td>
</tr>
<tr>
    <td rowspan="3">
        'script'
    </td>
    <td rowspan="3">
        (なし)
    </td>
    <td>
        'db-operation'
    </td>
    <td>
        データベース処理の前後に行う処理の指定。スクリプトを実行する場面で、値は'load', 'update', 'new', 'delete'のいずれか
    </td>
</tr>
<tr>
    <td>
        'situation'
    </td>
    <td>
        スクリプトの実行を行うタイミングで、'pre', 'presort', 'post'のいずれかの値を取る（'presort'はFileMaker Serverのみサポート）
    </td>
</tr>
<tr>
    <td>
        'definition'
    </td>
    <td>
        MySQLは指定したSQLコマンドを実行、FileMaker Serverはスクリプト名を指定。（FileMaker Serverでforeign-keyの指定されたテーブルの読み込み時の設定はすべて無視される）
    </td>
</tr>
<tr>
    <td rowspan="3">
        'global'
    </td>
    <td rowspan="3">
        (なし)
    </td>
    <td>
        db-operation
    </td>
    <td>
        設定する場面で、値は 'load', 'update', 'new', 'delete'のいずれか（グローバルの設定はFileMaker Serverのみ）
    </td>
</tr>
<tr>
    <td>
        field
    </td>
    <td>
        グローバルフィールド名
    </td>
</tr>
<tr>
    <td>
        value
    </td>
    <td>
        グローバルフィールドに与える値
    </td>
</tr>
<tr>
    <td rowspan="9">
        'authentication'
    </td>
    <td>media-handling</td>
    <td></td>
    <td>メディアアクセス時の認証を通すためのクッキー情報を、このコンテキストの読み出し時にクライアントに送り込む。必要なときに値にtrueを指定する</td>
</tr>
<tr>
    <td rowspan="4">
        all
    </td>
    <td>
        'user'
    </td>
    <td>
        すべての操作について、このコンテキストを利用可能なユーザを配列で指定。この記述がなければすべての認証ユーザにアクセス権
    </td>
</tr>
<tr>
    <td>
        'group'
    </td>
    <td>
        すべての操作について、このコンテキストを利用可能なグループを配列で指定。この記述がなければすべてのグループにアクセス権
    </td>
</tr>
<tr>
    <td>
        'target'
    </td>
    <td>
        省略あるいは'table'なら、テーブル全体に対する権限の設定、'field-user'あるいは'field-group'ならレコードごとに権限を指定できる
    </td>
</tr>
<tr>
    <td>
        'field'
    </td>
    <td>
        'field-user'あるいは'field-group'に指定した場合、ユーザ名やグループ名を指定するフィールドのフィールド名
    </td>
</tr>
<tr>
    <td>
        load
    </td>
    <td>
        （allと同様）
    </td>
    <td>
        クエリーの操作について、このコンテキストに関する設定を行う
    </td>
</tr>
<tr>
    <td>
        update
    </td>
    <td>
        （allと同様）
    </td>
    <td>
        更新の操作について、このコンテキストに関する設定を行う
    </td>
</tr>
<tr>
    <td>
        new
    </td>
    <td>
        （allと同様）
    </td>
    <td>
        新規レコード作成の操作について、このコンテキストに関する設定を行う
    </td>
</tr>
<tr>
    <td>
        delete
    </td>
    <td>
        （allと同様）
    </td>
    <td>
        レコード削除の操作について、このコンテキストに関する設定を行う。ただし、targetとfieldは無視してテーブルに対する設定のみを利用
    </td>
</tr>
<tr>
    <td>
        extending-class
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        データアクセス時に処理プログラムを追加するクラスのクラス名を指定する
    </td>
</tr>
<tr>
    <td>
        protect-writing
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        この配列に指定したフィールド名に対する更新処理を禁止する
    </td>
</tr>
<tr>
    <td>
        protect-reading
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        この配列に指定したフィールド名から読み出したデータをクライアントに送る事を禁止する
    </td>
</tr>
<tr>
    <td rowspan="2">file-upload</td>
    <td rowspan="2">（なし）</td>
    <td>field</td>
    <td>コンテキスト内のここで指定したフィールドに対してファイルアップロードのコンポーネントが設定されている場合</td>
</tr>
<tr>
    <td>context</td>
    <td>この指定があると、指定したコンテキストのpathフィールドにファイルパスを値として指定する新規レコードを作成する。こちらのコンテキストとのリレーションが設定されていれば正しく外部キーが設定される</td>
</tr>
<tr>
    <td>
        'db-class'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        このコンテキストで使うデータアクセスクラスの名前（例：PDO、FileMaker_FX）この指定がなければ、IM_Entry関数の第3引数あるいはparams.phpの値が使われます。以下、'datatype'まで同様
    </td>
</tr>
<tr>
    <td>
        'dsn'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        [PDO]このコンテキストで使う接続時に指定するDSN
    </td>
</tr>
<tr>
    <td>
        'option'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        [PDO]このコンテキストで使うオプション指定。array型で指定
    </td>
</tr>
<tr>
    <td>
        'database'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        [FileMaker_FX]このコンテキストで使うデータベース名
    </td>
</tr>
<tr>
    <td>
        'user'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        [PDO][FileMaker_FX]このコンテキストで使うユーザ名
    </td>
</tr>
<tr>
    <td>
        'password'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        [PDO][FileMaker_FX]このコンテキストで使うパスワード
    </td>
</tr>
<tr>
    <td>
        'server'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        [FileMaker_FX]このコンテキストで使うサーバアドレス（例：127.0.0.1）
    </td>
</tr>
<tr>
    <td>
        'port'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        [FileMaker_FX]このコンテキストで使うサーバポート（例：80）
    </td>
</tr>
<tr>
    <td>
        'protocol'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        [FileMaker_FX]このコンテキストで使うサーバへの接続プロトコル（例：HTTP）
    </td>
</tr>
<tr>
    <td>
        'datatype'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        [FileMaker_FX]このコンテキストで使うサーバがサポートするデータ形式（例：FMPro7）
    </td>
</tr>
</table>
</div>
<p>
    認証についは別項目「ユーザ認証とアクセス権の動作について」も参照してください。
</p>

<p>
    'relation'、'query'、'sort'、'script'については、配列の配列を指定します。サンプルのソース等で具体例を見てください。
</p>

<p>
    それぞれのパラメータの解釈は、データベースドライバによって異なる場合があります。
</p>

<h3>第2引数、オプション設定</h3>

<p>
    こちらは、「定義ファイルのオプション設定」と呼ぶことにします。
</p>

<div class="table">
<table>
<tr>
    <th colspan="3">
        配列指定
    </th>
    <th rowspan="2">
        値
    </th>
</tr>
<tr>
    <th width="120">
        第1次元
    </th>
    <th width="80">
        第2次元
    </th>
    <th width="160">
        第3次元
    </th>
</tr>
<tr>
    <td>
        'separator'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        テーブル名とフィールド名を区切る文字（既定値は「@」）
    </td>
</tr>
<tr>
    <td rowspan="3">
        'formatter'
    </td>
    <td rowspan="3">
        (なし)
    </td>
    <td>
        'field'
    </td>
    <td>
        データコンバータを適用するフィールド名
    </td>
</tr>
<tr>
    <td>
        'converter-class'
    </td>
    <td>
        データコンバータクラス名
    </td>
</tr>
<tr>
    <td>
        'parameter'
    </td>
    <td>
        コンバータクラスに与えるパラメータ
    </td>
</tr>
<tr>
    <td>
        'aliases'
    </td>
    <td>
        (なし)
    </td>
    <td>
        エイリアス名
    </td>
    <td>
        エイリアスに対応する値。この値は正しい1つのターゲット指定である必要がある。この指定があれば、ターゲット指定の代わりに、エイリアス名をリンクノードに指定できる。
    </td>
</tr>
<tr>
    <td rowspan="2">
        'browser-compatibility'
    </td>
    <td rowspan="2">
        (なし)
    </td>
    <td>
        文字列
    </td>
    <td>
        キーにブラウザを示す文字列（safari, msieなど）を指定し、値にはバージョン番号を指定する。バージョン番号の後に+や-をつけて、以上あるいは以下をのバージョンを示すことができる
    </td>
</tr>
<tr>
    <td>
        配列
    </td>
    <td>
        要素にはキーにOSを指定し、その要素に前の行に説明のあるバージョン番号とプラス／マイナス記号を指定する。
    </td>
</tr>
<tr>
    <td>
        'transaction'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        編集可能コンポーネントの変更時の書き戻しについて、'none'なら行わない、'automatic'ならchangeイベントが発生するたびに書き戻す。省略するとautomaticが指定されたものとみなす
    </td>
</tr>
<tr>
    <td rowspan="11">
        'authentication'
    </td>
    <td>
        'user'
    </td>
    <td>
    </td>
    <td>
        利用可能なユーザを配列で指定。この記述がなければすべてのユーザにアクセス権。データベースのネイティブユーザで認証する場合には、値を「array('database_native')」と指定する。
    </td>
</tr>
<tr>
    <td>
        'group'
    </td>
    <td>
    </td>
    <td>
        利用可能なグループを配列で指定。この記述がなければすべてのグループにアクセス権
    </td>
</tr>
<tr>
    <td>
        'user-table'
    </td>
    <td>
    </td>
    <td>
        ユーザ情報が保存されているテーブル名。省略すると'authuser'
    </td>
</tr>
<tr>
    <td>
        'group-table'
    </td>
    <td>
    </td>
    <td>
        ユーザ情報が保存されているテーブル名。省略すると'authgroup',
    </td>
</tr>
<tr>
    <td>
        'corresponding-table'
    </td>
    <td>
    </td>
    <td>
        ユーザとグループが対応づけられている情報が保存されているテーブル名。省略すると'authcor',
    </td>
</tr>
<tr>
    <td>
        'challenge-table'
    </td>
    <td>
    </td>
    <td>
        チャレンジが保存されているテーブル名。省略すると'issuedhash',
    </td>
</tr>
<tr>
    <td>
        'authexpired'
    </td>
    <td>
    </td>
    <td>
        認証が自動的に継続される時間を秒数で指定する。省略すると'3600（1時間）', // Set as seconds.
    </td>
</tr>
<tr>
    <td>
        'storing'
    </td>
    <td>
    </td>
    <td>
        認証情報のクライアントへの保存を指定。'cookie'ならPathを指定しないでクッキーに保存（既定値）、'cookie-domainwide'ならドメイン全体で共有できるようにクッキーに保存、'none'ならクッキーに保存しない
    </td>
</tr>
<tr>
    <td>
        'realm'
    </td>
    <td>
    </td>
    <td>
        認証領域名。ログインパネルの上部に表示される。また、認証情報を記憶するクッキーの名称の末尾に付与される。
    </td>
</tr>
<tr>
    <td>
        'email-as-username'
    </td>
    <td>
    </td>
    <td>
        trueを指定すると、authuserテーブルのusernameと同時にemailフィールドも検索する。つまり、電子メールアドレスでの認証が可能になる。既定値はfalse
    </td>
</tr>
<td>
    'issuedhash-dsn'
</td>
<td>
</td>
<td>
    issuedhashテーブルに対するDSNを指定する。たとえば、FileMakerデータベースで、issuedhashテーブルをSQLiteで運用する場合に使える
</td>
</tr>
<tr>
    <td>
        'media-root-dir'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        メディアアクセスに対して定義ファイルにリダイレクトの設定をWebサーバで行う。そうすれば、この設定に指定したディレクトリにある画像などのメディアファイルを読み出す。
    </td>
</tr>
<tr>
    <td>
        'media-context'
    </td>
    <td>
    </td>
    <td>
    </td>
    <td>
        メディアアクセスに認証を設定するとき、ここで指定したコンテキストにアクセスしたときにメディアの認証用のトークンをクライアントに届ける。このトークンをクライアントが持つ事で、メディアプロキシが認証される
    </td>
</tr>
</table>
</div>
<p>
    認証についは別項目「ユーザ認証とアクセス権の動作について」も参照してください。
</p>

<p>
    browser-compatibilityは、params.phpファイルでも指定できますが、ここに指定をした方が有効になります。この指定に含まれているブラウザで通常処理を行い、含まれていないブラウザでは処理を行わないようにします。
</p>

<p>
    以前「trigger」というキーワードを書いていましたが、この設定は不要で、普通にノードに対してJavaScriptの記述をすればいいので、設定としては組み込まないこととします。
</p>

<h3>第3引数、データベースへの接続情報</h3>

<p>
    データベースヘの接続情報を設定します。この設定を「定義ファイルのデータベース接続設定」と呼ぶことにします。なお、INTER-Mediator.phpと同じフォルダに入れておく「params.php」でも、データベース接続に関する指定が可能です。ページごとに接続情報が違うなら、この引数に指定してもいいのですが、たくさんのファイルで同じ設定ならparams.phpで指定をしてもいいでしょう。さらに、IM_Entry関数の第一パラーメータで指定する配列のコンテキストに対しても設定できます。params.php内で指定できる変数についてもまとめておきます。なお、必要な情報は、データベースクラスごとに異なります。以下の表には、値を必要とするクラスも記述してあります。
</p>

<div class="table">
    <table>
        <tr>
            <th>
                インデックス
            </th>
            <th>
                値
            </th>
            <th>
                params.phpで変数名
            </th>
        </tr>
        <tr>
            <td>
                'db-class'
            </td>
            <td>
                データアクセスクラスの名前（例：PDO、FileMaker_FX）
            </td>
            <td>
                $dbClass
            </td>
        </tr>
        <tr>
            <td>
                'dsn'
            </td>
            <td>
                [PDO]接続時に指定するDSN
            </td>
            <td>
                $dbDSN
            </td>
        </tr>
        <tr>
            <td>
                'option'
            </td>
            <td>
                [PDO]オプション指定。array型で指定
            </td>
            <td>
                $dbOption
            </td>
        </tr>
        <tr>
            <td>
                'database'
            </td>
            <td>
                [FileMaker_FX]データベース名
            </td>
            <td>
                $dbDatabase
            </td>
        </tr>
        <tr>
            <td>
                'user'
            </td>
            <td>
                [PDO][FileMaker_FX]ユーザ名
            </td>
            <td>
                $dbUser
            </td>
        </tr>
        <tr>
            <td>
                'password'
            </td>
            <td>
                [PDO][FileMaker_FX]パスワード
            </td>
            <td>
                $dbPassword
            </td>
        </tr>
        <tr>
            <td>
                'server'
            </td>
            <td>
                [FileMaker_FX]サーバアドレス（例：127.0.0.1）
            </td>
            <td>
                $dbServer
            </td>
        </tr>
        <tr>
            <td>
                'port'
            </td>
            <td>
                [FileMaker_FX]サーバポート（例：80）
            </td>
            <td>
                $dbPort
            </td>
        </tr>
        <tr>
            <td>
                'protocol'
            </td>
            <td>
                [FileMaker_FX]サーバへの接続プロトコル（例：HTTP）
            </td>
            <td>
                $dbProtocol
            </td>
        </tr>
        <tr>
            <td>
                'datatype'
            </td>
            <td>
                [FileMaker_FX]サーバがサポートするデータ形式（例：FMPro7）
            </td>
            <td>
                $dbDataType
            </td>
        </tr>
    </table>
</div>
<h3>第4引数、デバッグ情報の表示</h3>

<p>
    数値かfalseかを指定します。false以外だと、デバッグ情報をページの最初に表示します。1ないしは2を指定でき、2の方が多くの情報を出します。
</p>

<h2>INTER-MediatorによるWebページ生成</h2>

<p>
    INTER-Mediatorは、WebページのDOM構造をたどり、データベースとリンクするノード（以後「リンクノード」と記述）をさがします。そして、そのリンクノードの上位のノードをたどり、「エンクロージャ」と「リピータ」となるノードを探します。リピータ自身あるいはリピータに含まれるリンクノードをすべて集めてデータベースにアクセスします。そして、レコードの数だけリピータを繰り返して、データベースの内容をページに表示します。
</p>

<h3>リンクノードでのターゲット指定</h3>
<ul>
    <li>任意の要素をリンクノードにすることができます。</li>
    <li>class属性に「IM[table@field@target]」の記述で記載されいているものをリンクノードとみなします。</li>
    <li>title属性に「table@field@target」の記述で記載されいているものをリンクノードとみなします。</li>
    <li>
        複数の設定があってもかまいません。class属性の場合は、「IM[table@field@target|table@field@target|...]」と記述します。title属性の場合は「table@field@target|table@field@target|...」と記述します。
    </li>
    <li>
        title属性、class属性、いずれもリンクノードの指定にできなくすることができます。INTER-Mediatorのconstructメソッドの最初にあるtitleAsLinLinfo、classAsLinkInfo変数にfalseを入れれば、それぞれの属性に記述されたリンク指定は無視します。
    </li>
</ul>
<h3>ターゲット指定について</h3>

<p>
    「table@field@target」がひとまとまりのターゲット指定となります。
</p>
<ul>
    <li>tableはテーブル名を記述します。IM_Entry関数の第一引数に指定した配列のname属性の値を記述できます。</li>
    <li>
        fieldはフィールド名を指定します。IM_Entry関数の第一引数に指定した配列の中で、name属性に対応したテーブルアクセスの中にフィールドが含まれていれば、そのフィールドの値を利用して、リンクノードの値を変更あるいは設定します。
    </li>
    <li>targetはノードのどの属性にフィールド値を差し込むかを指定します。</li>
</ul>
<p>
    targetの指定は以下のようなルールになります。
</p>
<ul>
    <li>省略すると、ノードの値として設定します。</li>
    <li>「innerHTML」の場合は、ノードのinnerHTML属性にフィールドの値を設定します。</li>
    <li>「nodeText」の場合はテキストノードを作成して子ノードとして追加します。</li>
    <li>「style.STYLENAME」の場合は、STYLENAMEで指定したスタイルに値として追加します。たとえば、「style.backgroundColor」は背景色のスタイル属性に値を指定します。</li>
    <li>targetの最初の文字が「#」の場合、innerHTMLないしは属性を指定していれば、既存のノードのデータに追加します。</li>
    <li>targetの最初の文字が「$」の場合、既存のノードのデータに含まれる$の部分を、データベースのフィールドの値に置き換えます。</li>
</ul>
<h3>エンクロージャとリピータ</h3>

<p>
    エンクロージャとリピータとなり得るノードの組み合わせを以下の表に示します。
</p>

<div class="table">
    <table>
        <thead>
        <tr>
            <th>
                形態
            </th>
            <th>
                Enclosure
            </th>
            <th>
                Repeater
            </th>
            <th>
                Linked Element
            </th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>
                表
            </td>
            <td>
                TBODY
            </td>
            <td>
                TR
            </td>
            <td>
                any elements
            </td>
        </tr>
        <tr>
            <td>
                汎用
            </td>
            <td>
                DIV._im_enclosure
            </td>
            <td>
                DIV._im_repeater
            </td>
            <td>
                any elements
            </td>
        </tr>
        <tr>
            <td>
                汎用
            </td>
            <td>
                SPAN._im_enclosure
            </td>
            <td>
                SPAN._im_repeater
            </td>
            <td>
                any elements
            </td>
        </tr>
        <tr>
            <td>
                番号リスト
            </td>
            <td>
                OL
            </td>
            <td>
                LI
            </td>
            <td>
                LI itself or inside of LI elements
            </td>
        </tr>
        <tr>
            <td>
                箇条書き
            </td>
            <td>
                UL
            </td>
            <td>
                LI
            </td>
            <td>
                LI itself or inside of LI elements
            </td>
        </tr>
        <tr>
            <td>
                ポップアップ、リスト
            </td>
            <td>
                SELECT
            </td>
            <td>
                OPTION
            </td>
            <td>
                OPTION itself
            </td>
        </tr>
        </tbody>
    </table>
</div>
<p>
    テーブルの場合で説明します。たとえば、テーブルのあるセル、つまりTDタグで囲まれた中に、DIVタグ等で記述されたリンクノードがあったとします。そのリンクノードから上位のノードにたどって、TRをリピータとします。TRの1つ上位のノードはTBODYに必ずなります。そのTBODYがエンクロージャとなります。リンクノードに記述された情報からテーブルがわかり、そのテーブルへアクセスします。そして、レコードの値をリンクノードの定義に従って、ノードに反映されます。もし、レコードが複数あれば、リピータを複製して、その複製した一連のノードに対してリンクノードの処理を行います。ページファイルを作るときは、通常、TRタグによる要素が1つのテーブルを作りますが、レコードの数だけ行数が増えるということになります。なお、リピータとなるTRタグの要素は複数個あってもかまいません。レコードの数だけ複数のTRのセットが複製されて、データの反映が行われます。</p>

<h3>レコードがない場合の表示</h3>

<p>
    レコードがあれば、リピーターを複製していくつかのオブジェクトがページに見えますが、そのままだと、レコードがない場合、リピーターが全くない状態になってしまいます。そこで、リピーターの1つのclass属性を「_im_for_noresult_」とします。すると、classが「_im_for_noresult_」のリピータはレコードが存在すれば単に消しさられますが、レコードがないときにはこのリピータが1つだけエンクロージャーの中に配置されます。「レコードがありません」などの記述をこの方法で組み込めます。</p>


<h2>検索や並べ替えの動作と指定</h2>

<p>INTER-Mediatorは、検索に関して以下の3つの設定個所があります。あるいは、以下のような検索条件が付与されて、データベースの読み出しが行われます。</p>


<ol>


    <li>定義ファイルのコンテキストの中のqueryの設定</li>


    <li>INTERMediatorオブジェクトのadditionalConditionプロパティ（JavaScript）</li>


    <li>リレーションによって決まる外部キーと対応キーとの対応（定義ファイルのコンテキストの中のrelationの設定）</li>


</ol>


<p>
    定義ファイルのqueryでの設定は、「常に適用されたい検索条件」を与えるのに便利です。たとえば、あるフィールドの値が「3」のものだけをいつも選択するとか、消し込みのフィールドがあって消し込まれていないレコードだけをとってくるというような場合です。</p>


<p>
    一方、ユーザが入力した検索条件のようなデータは、INTERMediatorオブジェクトのadditionalConditionプロパティを使って指定ができます。テキストフィールドに入力したテキストやあるいは計算結果などを検索条件に与えたい場合は、この方法で指定をします。</p>


<p>
    そして、リレーションは、エンクロージャーとリピーターによる展開中に、さらに内包するエンクロージャーとリピーターが見つかったとき、内側のコンテキストのrelation設定を参照して、外側のレコードに対応した、つまり関連のあるレコードを取り出すための条件を与えます。</p>


<p>これら3つの条件は、無条件にANDで合成されます。</p>


<h3>コンテキストのqueryの指定方法</h3>


<p>定義ファイルのコンテキストのqueryは、キーとして、field、operator、valueを持つ配列を指定します。その指定を複数できるので、結果として、queryキーに対する値は配列の配列となります。</p>


<p>PDO対応のデータベースアクセスクラスを利用すると、単に「field operator 'value'」という形式での式が構築されます。値についてはquoteメソッドで処理をしてあります。従って、array( 'field'=&gt;'age',
    'operator'=&gt;'&gt;', 'value'=&gt;'19'
    )のような指定が一例です。文字列のワイルドカードを使う場合には、データベースエンジンに従った記述が必要です。たとえば、MySQLで前方一致させるには、array( 'field'=&gt;'name', 'operator'=&gt;'LIKE',
    'value'=&gt;'%田太郎' ) のような配列を指定します。operatorを省略すると、= とみなします。</p>


<p>'field' の値が '__operation__'
    の項目があれば、そこで区切りを入れます。そして区切りで分割したそれぞれについて、AND条件が適用された式が作られ、区切りで分割された固まりについてはOR演算となります。また、'field' の値が '__operation__'
    の項目の 'operator' が 'ex' なら、ORとANDを入れ替えます。言い換えれば、特に何もしなければ、AND条件で結びつけられますが、ANDやORを組み合わせた条件指定も可能ということです。'field' の値が
    '__operation__' の項目はいくつあってもかまいません。</p>


<div class="code">


   <pre><code>'qyery' =&gt; array(

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'age', 'operator'=&gt;'&gt;', 'value'=&gt;'19' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'year', 'operator'=&gt;'&gt;', 'value'=&gt;'1980' ))


       生成される条件文：age &gt; '19' AND year &gt; '1980'</code></pre>


</div>


<div class="code">


   <pre><code>'qyery' =&gt; array(

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'age', 'operator'=&gt;'&gt;', 'value'=&gt;'19' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'year', 'operator'=&gt;'&gt;', 'value'=&gt;'1980' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'__operation__' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'age', 'operator'=&gt;'&lt;', 'value'=&gt;'39' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'year', 'operator'=&gt;'&lt;', 'value'=&gt;'2006' ))


       生成される条件文：(age &gt; '19' AND year &gt; '1980') OR (age &lt; '39' AND year &lt; '2006')</code></pre>


</div>


<div class="code">


   <pre><code>'qyery' =&gt; array(

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'age', 'operator'=&gt;'&gt;', 'value'=&gt;'19' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'year', 'operator'=&gt;'&gt;', 'value'=&gt;'1980' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'__operation__', 'operator'=>'ex' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'age', 'operator'=&gt;'&lt;', 'value'=&gt;'39' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'year', 'operator'=&gt;'&lt;', 'value'=&gt;'2006' ))


       生成される条件文：(age &gt; '19' OR year &gt; '1980') AND (age &lt; '39' OR year &lt; '2006')</code></pre>


</div>


<div class="code">


   <pre><code>'qyery' =&gt; array(

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'age', 'operator'=&gt;'&gt;', 'value'=&gt;'19' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'year', 'operator'=&gt;'&gt;', 'value'=&gt;'1980' ),

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'field'=&gt;'__operation__', 'operator'=>'ex' ))


       生成される条件文：age &gt; '19' OR year &gt; '1980'</code></pre>


</div>


<p>なお、ANDとORの組み合わせしかできないのかと思われるかもしれませんが、すべての論理式が論理和標準形ないしは論理積標準形で表現できるという定理があるので、この仕様ですべての論理式が記述できると言えるかと思われます。</p>


<p>FileMaker
    Serverの場合、FileMaker側の仕様の制限として、検索条件は全部ANDか全部ORかで結ぶしかできません。ANDとORを組み合わせることはできないのです。コンテキストのqueryキーの値、あるいはaddtionalConditionに「raray(
    'field'=&gt;'__operation__', 'operator'=>'or'
    )」を加えれば、OR演算を行います。この指定がなければAND演算になります。OR演算を指定した場合、外部キーの検索条件もORになってしまい、リレーションが正確にとれませんので、その点は十分に注意が必要です。</p>


<h3>INTERMediatorオブジェクトのadditionalConditionプロパティに指定する検索条件</h3>


<p>JavaScriptのプログラムで、INTERMediator.construct(true)
    を実行するよりも前に、例えば以下のようなプログラムを実行します。additionalConditionプロパティは配列で、最初のインデックスはコンテキスト名、つまり定義ファイルでの name
    キーに対応する値を指定します。右辺の条件は、もちろん、該当するコンテキストにしか適用されません。オブジェクトの値については前のqueryについての説明とおおむね共通です。OR条件とAND条件がどちらも出てくるような条件も記述できます。条件が一組の場合はオブジェクトとして記述できます。2つ以上あるときはオブジェクトの配列として記述します。</p>


<div class="code">


   <pre><code>INTERMediator.additionalCondition[コンテキスト名] = {field:'age', operator:'&gt;', value: 19}

       INTERMediator.additionalCondition[コンテキスト名] = [{field:'age', operator:'&gt;', value: 19}, {field:'year',
       operator:'&gt;', value: 1999}]</code></pre>


</div>


<h3>コンテキストのrelationキーの値</h3>


<p>
    こちらもqueryと同様、配列の配列という形式をとります。キーはqueryと違います。外側のエンクロージャー／リピータとその内側のエンクロージャー／リピーターがあるとします。外側はmaster、内側はdetailというコンテキスト名で定義されているとします。</p>


<div class="code">


   <pre><code>array(

       &nbsp;&nbsp;&nbsp;&nbsp;array( 'name' => 'master', 'key' => 'id' )),

       array(

       &nbsp;&nbsp;&nbsp;&nbsp;array(

       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'name' => 'detail',

       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'relation' => array( array( 'foreign-field' => 'master_id',
       'join-field' => 'id', 'operator' => '=' ))),</code></pre>


</div>


<p>
    外側のコンテキストの1レコードを処理すると、その内部にあるエンクロージャー／リピーターが見つかります。そのとき、コンテキスト名がdetailのrelationキーの値を参照します。そして、join-fieldキーについては、外側の1レコードに存在する値を取り出し、foreign-fieldキーの値とoperatorキーの値を使って検索条件を作ります。たとえば、外側のレコードのidフィールドの値が34だった場合、「master_id
    = '34'」という条件を作成し、AND条件として追加します。relationの配列は配列が複数あってもかまいません。その場合、すべての指定で生成される条件式のANDをとります。</p>


<p>なお、join-fieldの指定は必須です。不要と思われるかもしれませんが、必ずしも主キーとリンクしているとは限らないので指定は必須としました。</p>


<h3>検索結果の並べ替えに関して</h3>


<p>INTER-Mediatorは、検索結果の並べ替え関して以下の2つの設定個所があります。検索のクエリに対して、並べ替えの順序を決める基準となるフィールドを指定できます。</p>


<ol>


    <li>定義ファイルのコンテキストの中のsortの設定</li>


    <li>INTERMediatorオブジェクトのadditionalSortKeyプロパティ（JavaScript）</li>


</ol>


<p>
    定義ファイルのsortでの設定は、常に適用されるソートキーです。一方、additionalSortKeyプロパティはプログラムで状況に応じて設定されるソートキーです。検索時にはこれらが合成されて、並べ替えを行います。優先順位は、additionalSortKeyプロパティの方が上位になります。また、それぞれの設定の中で、指定した順序で上位の並べ替えフィールドとなります。いずれも、配列の形式で指定をし、fieldとdirectionというキーを指定します。fieldキーに対する値は1つのフィールド名を指定します。directionに対する値はデータベースエンジンに従います。たとえば、MySQLだと、ASCあるいはDESCを指定しますが、FileMaker
    Serverはascendあるいはdescendを指定します。additionalSortKeyプロパティについては、addtionalConditionプロパティと同様、最初のインデックスはコンテキスト名を指定し、その後にオブジェクトあるいはオブジェクトの配列を指定します。</p>

<h2>ページ移動ナビゲーションの構築</h2>

<p>
    ページ移動のナビゲーションは、ページの中に、idが「IM_NAVIGATOR」のノードがあれば、そのノードの内容を置き換えてナビゲーションを作成します。「IM_NAVIGATOR」のidのノードがない場合には、ナビゲーションは表示されません。通常は、divタグの要素を「&lt;div
    id="IM_NAVIGATOR"&gt;&lt;/div&gt;」のように作っておくのがいいでしょう。</p>

<p>
    INTER-Mediator.constructメソッドは、ノードを見つけて自動的にページナビゲーションにしますが、それらの要素に以下のようなクラス設定をしています。つまり、ページで、これらのクラスに対してスタイルシートで定義を行えば、見栄えについては自由に設定ができます。</p>

<div class="table">
    <table>
        <tr>
            <th>要素名.クラス名</th>
            <th>設定先</th>
        </tr>
        <tr>
            <td>.IM_NAV_panel</td>
            <td>ナビゲーションそのもの。つまり、idが「IM_NAVIGATOR」のノードに設定される</td>
        </tr>
        <tr>
            <td>span.IM_NAV_info</td>
            <td>文字情報を表示する部分に設定される</td>
        </tr>
        <tr>
            <td>span.IM_NAV_button</td>
            <td>クリックできるボタンに対して設定される</td>
        </tr>
        <tr>
            <td>span.IM_NAV_disabled</td>
            <td>クリックできないボタンに対して設定される</td>
        </tr>
    </table>
</div>

<p>
    ナビゲーション領域の文言等は、INTERMediator.navigationLabelに配列を設定することで、任意に設定できます。配列のインデックスと対応する箇所は以下の表に示します。INTERMediator.navigationLabelに何も設定しない場合には、表の既定値が画面に見えます。</p>

<div class="table">
    <table>
        <tr>
            <th>インデックス</th>
            <th>設定対象</th>
            <th>既定値</th>
            <th>非表示</th>
        </tr>
        <tr>
            <td>0</td>
            <td>最初のレコードに戻る</td>
            <td>&lt;&lt;</td>
            <td>インデックス0〜3</td>
        </tr>
        <tr>
            <td>1</td>
            <td>前のページに戻る</td>
            <td>&lt;</td>
            <td>無関係</td>
        </tr>
        <tr>
            <td>2</td>
            <td>次のページに進む</td>
            <td>&gt;</td>
            <td>無関係</td>
        </tr>
        <tr>
            <td>3</td>
            <td>最後のレコードに進む</td>
            <td>&gt;&gt;</td>
            <td>無関係</td>
        </tr>
        <tr>
            <td>4</td>
            <td>レコード番号の直前</td>
            <td>レコード番号</td>
            <td>インデックス4〜7</td>
        </tr>
        <tr>
            <td>5</td>
            <td>レコード番号の範囲の間の文字列</td>
            <td>-</td>
            <td>無関係</td>
        </tr>
        <tr>
            <td>6</td>
            <td>レコード番号範囲と全レコード数の間の文字列</td>
            <td>/</td>
            <td>無関係</td>
        </tr>
        <tr>
            <td>7</td>
            <td>全レコード数の後の文字列</td>
            <td>（空文字列）</td>
            <td>無関係</td>
        </tr>
        <tr>
            <td>8</td>
            <td>更新ボタンの名称</td>
            <td>更新</td>
            <td>インデックス8</td>
        </tr>
    </table>
</div>
<p>
    INTERMediator.navigationLabelに指定する配列は9つの要素を指定します。それぞれ、インデックスに要素が対応します。要素がnullだと既定値のままになります。文字列を指定すると、その文字列に置き換わります。インデックスが0、4,、8の要素に関しては、「非表示」の列に示したインデックスのものが非表示になります。たとえば、以下の記述だと、Refreshボタンのみが消えて他は既定とおりのものが表示されます。</p>

<p>INTERMediator.navigationLabel = [null, null, null, null, null, null, null, null, false];</p>

<h2>HTMLのUIコンポーネントの扱い</h2>

<h3>テキストフィールド</h3>

<p>
    INPUTタグ要素のtype属性がtextの場合、ターゲット指定の3つ目の指定は省略できます。その場合、value属性に値が設定されます。また、onchange属性にINTERMediator.changeValue(*)の呼び出しプログラムが登録されるので、テキストを編集し、フォーカスを別のフィールドに移動したときなどに、テキストフィールドの内容がデータベースに書き戻されます。</p>

<h3>テキストエリア</h3>

<p>ターゲット指定の3つ目の指定は省略できます。すると、TEXTAREAタグ要素のテキストとして設定されます。</p>

<h3>ポップアップメニュー／リスト</h3>

<p>
    SELECTタグの要素自体が値を持つコンポーネントです。SELECTタグ要素のターゲット指定の3つ目の項目を省略すると、SELECT要素の選択値として指定されます。また、OPTIONタグは決められたものでもかまいませんが、データベースからも値を設定できます。このとき、自動的に、SELECT/OPTIONタグがエンクロージャー／リピータとなります。OPTIONタグはSELECTタグ要素の選択値に対応するvalue属性と、実際にメニュー項目として見えるOPTIONタグ要素のテキストの2つの設定が必要になるでしょう。従って、「&lt;option
    class="IM[contact_way@id@value|contact_way@name]"&gt;&lt;/option&gt;」のようなターゲット指定が2つありょうなタグ要素をSELECTの中に1つだけ作っておき、ターゲット指定の1つ目の名前のコンテキスト定義を定義ファイルに記述しておきます。</p>

<h3>チェックボックス</h3>

<p>
    データベースから読み出された特定のフィールドのデータがチェックボックスのINPUTタグ要素とリンクされている場合、そのタグのvalue属性を調べます。そして、データとvalue属性が一致していればチェックを入れます。データの有無ではなく、valueとの一致を調べます。また、書き戻す場合は、チェックが入ったときはvalue属性の値、チェックがなくなった場合には空文字列を書き戻します。通常、数値フィールドで、1ならチェックあり、それ以外ならチェックなしといったデータの持たせ方をするのが順当でしょう。</p>

<h3>ラジオボタン</h3>

<p>
    ラジオボタンに展開したい場合、同一のターゲット指定のINPUTタグでtype属性が「radio」のものを並べます。すると、name属性を自動的に設定し、複数レコードが繰り返されたときでも、問題なく処理できるようになります。それぞれのINPUTタグ要素のvalue属性はおのおのが自分の値を持ちます。データベースのフィールドの値とvalue属性の値を比べて同一のものが選択されます。</p>

<h3>隠しフィールド</h3>

<p>
    INPUTタグ要素のtype属性が「hidden」のものがよく利用されますが、むしろ、divやspanを使っていちばん外側の要素のdisplayスタイルをnoneにしておくという手段が使えます。たとえば、マスターの値を見えないタグ要素としてページ上に展開し、JavaScriptでそれらを得るという手も使えます。</p>

<h2>入力フォーム型ページの作成</h2>

<p>アンケートの回答のような、入力フォームがあってその内容に従った新規レコードを作るだけのようなページの作り方をここで説明します。そのようなページを作るのに必要なことは以下の通りです。</p>
<ul>
    <li>HTMLでフォームを作るが、FORMタグは不要。必要なテキストフィールドと、登録ボタンを作成する。ただし、テキストフィールドなどは、1つのエンクロージャにまとめておく。</li>
    <li>定義ファイルに、レコードの作成が可能なコンテキストを定義する。</li>
    <li>入力フォームにしたいエンクロージャのclass属性を「_im_post」とする。</li>
    <li>HTMLのフォームの入力要素をリンクノードにします。つまり、前のコンテキストの名前（context）と対応するテーブルのフィールド名（field）に対して、class="IM[context@field]"
        をタグの中に記述する。
    </li>
    <li>「登録」ボタンはBUTTONタグで作成し、class属性に「_im_post」を含める。</li>
</ul>
<p>
    登録ボタンを押した後の動作については、コンテキストの定義の表（ページの前の方）の「post-」で始まる3つの項目が用意されています。ボタンを何度も押す事を避けるために、ボタンをメッセージで置き換えたり、別のページに移動したり、ページの再描画ができます。</p>

<p>
    この機能を使う場合、「_im_post」を指定したエンクロージャーの外部にあるエンクロージャーに対しては、普通にページ合成ができるので、データベースアクセスの結果と、入力フォームを混在させることもできます。なお、入力フォームの内部のエンクロージャーの展開は行いません。</p>

<p>登録ボタンをクリックした後に独自のプログラムを追加したい場合は、以下のような記述の関数を定義します。メッセージ表示、ページ再合成、ページ移動が定義されていた場合、それらよりも前に、以下に定義した関数を実行します。</p>

<div class="code"><pre><code>INTERMediatorOnPage.processingAfterPostOnlyContext = function(node){
    // any program here.
    };</code></pre>
</div>
<h2>ブラウザのバージョンを調べる仕組み</h2>

<p>ブラウザのバージョンを調べて、一定のもの以外は表示できないようにしたいと思うこともあります。この機能を、必要に応じて利用できるようにしました。</p>


<p>
    まず、INTER-Mediator.phpと同じディレクトリにある$paramsファイルに、変数名$browserCompatibilityという変数を定義し、配列記述します。配列の記述方法は表に示します。作成例も紹介します。。</p>


<div class="table">


    <table>


        <tr>
            <th>次元</th>
            <th>指定内容</th>
            <th>指定する値の例</th>
        </tr>


        <tr>
            <td>第1次元</td>
            <td>ブラウザの種類</td>
            <td>msie, firefox, safari, chrome, opera</td>
        </tr>


        <tr>
            <td>第2次元</td>
            <td>配列（OSを示すキー）</td>
            <td>mac, win</td>
        </tr>


        <tr>
            <td></td>
            <td>バージョン記述文字列</td>
            <td>3+, 4-</td>
        </tr>


        <tr>
            <td>第3次元</td>
            <td>バージョン記述文字列（第2次元が配列のとき）</td>
            <td>3+, 4-</td>
        </tr>


    </table>


</div>


<div class="code">


   <pre><code>$browserCompatibility = array(

       'msie' => '7+',
       'firefox' => '2+',

       'safari' => array( 'win' => '4+', 'mac' => '3+' ),

       'chrome' => '1+',

       'opera' => '1+',
       );</code></pre>


</div>


<p>
    「バージョン記述文字列」は、数字とプラスないしはマイナスで指定します。「3+」は3以上、「3-」は3以下のバージョンで利用できることを示します。プラスあるいはマイナスを付けないと、その数値のバージョンのみです。ブラウザ名やOSは、大文字小文字は関係ありません。</p>


<p>前の例だと、Safariのみ、OSごとに分岐しています。WindowsならVer.4以上、MacならVer.3以上は利用可能であることを示しています。</p>


<h3>ブラウザの互換性をメッセージとして表示する</h3>


<p>
    JavaScriptベースで動くINTER-Mediatorにとって、これがいちばん難しい仕事かもしれません。ブラウザによっては、JavaScriptが動かないこともあるかもしれないのです。したがって、ベストプラクティスはまだ発見できていません。しかしながら、なんとか、なるかなというところまで来ました。</p>


<ol>


    <li>
        ページファイルの中の、bodyタグ要素の直下あたりに、INTER-Mediatorが一切しない場合のメッセージを付けておく。たとえば、サンプルファイルの「WebSite」のindex.htmlにあるid=nonsupportedmessageのdivタグ要素。INTER-Mediatorの動作が成功すれば、このノードを削除するか表示しないようにする。これにより、JavaScriptが一切動かない状態でも、何らかのメッセージが見えるようになる。
    </li>


    <li>
        ページファイルの構築を以下のようなプログラムにする。INTERMediatorCheckBrowser関数で前に説明した$paramsファイルの変数の定義に従って、ブラウザの互換性をチェックする。もし、対応でないならfalseを返すので、ページ構築はしない。また、その場合は、body要素の中身をいちど全部クリアして、メッセージだけを表示する。もし、対応しているならnodeで示したノードを削除する。nodeはnullあるいは未指定でも構わない。
    </li>


</ol>


<div class="code">


   <pre><code>if (INTERMediatorCheckBrowser( node )) {

       INTERMediator.construct(true);

       }</code></pre>


</div>


<p>上記の2つのうち、一方だけでもかまいませんし、両方をやってもかまいません。また、チェックは不要ということなら、単にINTERMediator.construct(true);を呼び出すだけでもいいでしょう。</p>

<h2>クライアント側でのJavaScriptの処理</h2>

<p>
    INTER-Mediatorによって生成されたノード、あるいは生成するかもしれないノードについての処理をサポートしています。sample_invoiceというサンプルを参照するのがいいかと思います。この機能は、まだまだ未完成だと思っていますので、ご要望をお寄せください。</p>

<p>
    まず、ノードへの到達の最低限のこととして、同一のエンクロージャ内にあるノードへの参照がしたいと考えると思います。そのために、INTERMediatorOnPage.getNodeIdFromIMDefinition関数を用意しました。引数が2つありますが、最初の引数はターゲット指定、2つ目の引数は基準となるノードを指定します。基準ノードからエンクロージャを探し、その内部にある第1引数のターゲットを持つノードのid属性値を戻します。このid属性値は当然ながら重複がないように設定されているので、該当するノードを参照できるはずです。この仕組みがあれば、単価と個数をかけて金額にすることは、JavaScriptのプログラムで作成できるはずです。</p>

<p>また、INTERMediatorOnPageによって参照されるオブジェクトにexpandingEnclosureFinish(n,
    t)という関数を定義します。すると、この関数はページ内のエンクロージャの展開が終わる度に呼び出されます。変数nにはそのエンクロージャに関連している定義ファイルの第1引数に指定する配列のname属性の値が渡されます。2つ目の引数には、展開したノードのエンクロージャが指定されますが、INTERMediatorOnPage.getNodeIdFromIMDefinition関数の2つ目の引数に指定できる値になります。</p>

<h3>INTERMediatorOnPage.expandingEnclosureFinish (name,target) </h3>

<h3>INTERMediatorOnPage.《コンテキストで指定した名前》 (target) </h3>
<ul>

    <li>引数：name：展開が終わった箇所で利用した定義ファイルのコンテキストのname属性の値</li>
    <li>引数：target：展開が終わったエンクロージャのノード</li>
    <li>返り値：なし</li>
</ul>

<p>
    エンクロージャの展開が終わる度に呼び出されます。《コンテキストで指定した名前》は、定義ファイルのコンテキストの指定で、'post-enclosure'というキーに対応する文字列で、メソッド名を指定します。そのメソッドを上記のように定義して、プログラムを記述します。前者はすべてのコンテキスト、後者は指定したコンテキストに対しての処理のときだけに呼び出されます。実際には、ヘッダのscriptタグの要素内で、以下のように記述し、{
    }

    内に独自のプログラムを記述すします。</p>

<p>INTERMediatorOnPage.expandingEnclosureFinish = function(name,target) {
    }

</p>

<h3>INTERMediatorOnPage.expandingRecordFinish(name,repeaters)</h3>

<h3>INTERMediatorOnPage.《コンテキストで指定した名前》(repeaters)</h3>
<ul>

    <li>引数：name：展開が終わった箇所で利用した定義ファイルのコンテキストのname属性の値</li>
    <li>引数：repeaters：1レコード分の展開をしたリピーターの配列</li>
    <li>返り値：なし</li>
</ul>

<p>
    リピータの展開時に、1レコード分の処理が終わった度に呼び出される。《コンテキストで指定した名前》は、定義ファイルのコンテキストの指定で、'post-repeater'というキーに対応する文字列で、メソッド名を指定します。そのメソッドを上記のように定義して、プログラムを記述します。前者はすべてのコンテキスト、後者は指定したコンテキストに対しての処理のときだけに呼び出されます。実際には、ヘッダのscriptタグの要素内で、以下のように記述し、{
    }

    内に独自のプログラムを記述します。</p>

<p>INTERMediatorOnPage.expandingRecordFinish = function(name,repeaters) {
    }

</p>

<h3>INTERMediatorOnPage.getNodeIdFromIMDefinition( linkdef, target, seeking);
    <br>
    INTERMediatorOnPage.getNodeIdsFromIMDefinition( linkdef, target, seeking );
</h3>

<ul>

    <li>引数：linkdef：リンク設定を記述する。例えば、「&lt;input type="text" class="IM[item@unitprice]" /&gt;」については、引数に "item@unitprice"
        を指定する
    </li>
    <li>引数：target：基準となるノード</li>
    <li>引数：seeking：trueならtargetのノードそのものの子ノードを探す。そうでなければ、targetより上位のリピータを探してそのリピーターの子ノードを探す</li>
    <li>返り値：ノードのid属性を示す文字列、あるいはその配列。該当するノードが1つの場合は前者、複数の場合は後者の関数を利用する。</li>
</ul>

<h3>INTERMediatorOnPage.doAfterConstruct</h3>

<p>ページの合成処理が終わったときに呼び出す関数を指定します。引数のない関数、つまり function() { }
    を代入しておきます。INTERMediator.construct(true)でページ合成を行いますが、非同期に処理を進めるため、このステートメントの次に書かれた命令は、通常は合成途中に実行されるなど、少なくともページを作り終える前になってしまいます。ページができていないと取得できないような情報もあるので、このようなコールバックの仕組みを用意してあります。</p>

<h3>INTERMediatorLib.toNumber( str );</h3>

<p>引数の文字列を数値に変換する</p>

<h3>INTERMediatorLib.numberFormat( str, digit );
</h3>

<p>引数strの文字列を数値に変換し、カンマ区切りで表示する。小数点以下の桁数をdigitで指定する。</p>

<h3>INTERMediatorLib.objectToString(obj) </h3>

<p>オブジェクトを文字列表現にするが、やや癖があるので、結果を見て検討してください。</p>

<h3>INTERMediator.valueChange(idValue)</h3>

<p>引数にINTER-Mediatorによって展開されたノードのid属性値を指定すると、現在の値をもってデータベース側に更新を行う。INTER-Mediatorによる自動更新をしない場合に利用するかもしれない。</p>

<h3>INTERMediatorクラスのプロパティ</h3>
<h4>INTERMediator.debugMode = true | false</h4>

<p>デバッグモード（展開の過程をページの最初に表示）での実行を行う。IM_Entryの4つ目の引数でコントロールするのが手軽</p>
<h4>INTERMediator.separator = '@'</h4>

<p>リンク定義の区切り文字で、既定値は@</p>
<h4>INTERMediator.defDivider = :'|',</h4>
<h4>複数のリンク定義がある場合の区切り文字で、既定値は |</h4>
<h4>INTERMediator.additionalCondition = ....</h4>

<p>
    コンテキストに従ってデータベースのクエリを行うとき、ここで指定した検索条件が、他の条件に対してAND条件で追加される第1引数がコンテキストのname属性値、その後にオブジェクトないしはオブジェクトの配列を指定するが、オブジェクトはfield、operator、valueのプロパティを指定し、それぞれフィールド名、演算子、値を指定する</p>

<p>INTERMediator.additionalCondition['tableName'] = {
    field:xxx,operator:xxx,value:xxxx}

</p>

<p>INTERMediator.additionalCondition['tableName'] = [{
    field:xxx,operator:xxx,value:xxxx}

    , {
    field:xxx,operator:xxx,value:xxxx}

    ]</p>
<h4>INTERMediator.additionalCondition = ....</h4>

<p>コンテキストに従ってデータベースのクエリを行うとき、ここで指定したソート条件が設定される。コンテキストのソート条件より高い優先順になっている。</p>

<p>INTERMediator.additionalSortKey['tableName'] = {
    field:xxx,direction:xxxx}

</p>

<p>INTERMediator.additionalSortKey['tableName'] = [{
    field:xxx,direction:xxxx}

    , {
    field:xxx,direction:xxxx}

    ]</p>
<h4>INTERMediator.defaultTargetInnerHTML = true</h4>

<p>リンク設定のターゲット指定がない場合、既定値はテキストノードを作成して下位のノードとする。ここにtrueを指定すると、ターゲット指定がない場合にはinnerHTMLに代入する</p>
<h4>INTERMediator.navigationLabel = ...</h4>

<p>ナビゲーションのカスタマイズ／TBW</p>
<h4>INTERMediator.titleAsLinkInfo = true;</h4>

<p>titile属性の内容をリンク設定として解釈する。既定値はtrue</p>
<h4>INTERMediator.classAsLinkInfo = false;</h4>

<p>class属性にあるIM[ ] でかこった箇所をリンク設定として解釈する。既定値はtrue</p>

<h3>エラーメッセージ、デバッグメッセージ</h3>
<h4>INTERMediator.errorMessages:[],</h4>

<p>エラーメッセージの配列。pushメソッドで文字列を追加する</p>
<h4>INTERMediator.debugMessages:[],</h4>

<p>デバッグメッセージの配列。pushメソッドで文字列を追加する。</p>
<h4>INTERMediator.flushMessage()</h4>

<p>エラーメッセージやデバッグメッセージを表示する</p>

<h3>バリデーション処理後に呼び出される関数</h3>
<h4>INTERMediatorOnPage.doAfterValidationSucceed(target,linkInfo)</h4>

<p>バリデーションの設定がされていて、ルールの結果がtrueとなった直後に呼び出される。引数targetは調べたノードへの参照、linkInfoは対照となったリンク定義の文字列が得られる</p>

<h4>INTERMediatorOnPage.doAfterValidationFailure(target,linkInfo)</h4>

<p>
    バリデーションの設定がされていて、ルールの結果がfalseとなった直後に呼び出される。引数targetは調べたノードへの参照、linkInfoは対照となったリンク定義の文字列が得られる。テキストフィールドの値をもとにして計算処理をしている場合、間違えた値で再計算をしてしまっているかもしれないが、この関数は、元の値に戻された後に呼び出されるので、さらに再計算などを組み込むことができる。</p>

<h2>クライアントからの直接的なデータベース処理</h2>

<p>
    INTER-Mediatorは、INPUT、SELECT、TEXTAREAタグ要素を編集してフォーカスを離れる時（つまり、onchangeイベントを受けて）、自動的にデータを書き戻すようにしています。これら、現状では必ず作動します。選択できるようにすることはとりあえず、考えていません。</p>

<p>
    しかしながら、データベースの読み書きの処理はこれだけでは足りないと思われます。たとえば、DIVタグ要素をドラッグできるようにして、ドラッグ先の座標をデータベースに書き戻すようなことをしたいと思うかもしれません。その場合、イベント処理関数で、ノードの属性やスタイルの値を取り出して、データベース処理を自前でやりたくなります。そのために、以下のように、CRUDに対応した4つの関数を用意してあります。いずれも、引数はオブジェクト1つだけですので、指定に必要な属性を表で示します。</p>

<h3>INTERMediator_DBAdapter.db_query(args)　データベースからの取り出し</h3>

<p>関数の返り値は1レコードがオブジェクトとなった配列です。</p>

<div class="table">

    <table>

        <tr>
            <th>属性</th>
            <th>指定する値</th>
        </tr>

        <tr>
            <td>name</td>
            <td>定義ファイルのIM_Entry関数の第1引数に指定する配列のname属性の値</td>
        </tr>

        <tr>
            <td>records</td>
            <td>取り出すレコードの数（レコード数の上限）</td>
        </tr>

        <tr>
            <td>fields</td>
            <td>取り出すフィールドの名前の配列（現在はすべて*でアクセスしており無視される）</td>
        </tr>

        <tr>
            <td>parentkeyvalue</td>
            <td>外部キーフィールドの値</td>
        </tr>

        <tr>
            <td>conditions</td>
            <td>{field:xx, operator:xx, value:xx} の形式のオブジェクトの配列。検索条件をANDで追加する</td>
        </tr>

        <tr>
            <td>useoffset</td>
            <td>trueならオフセットの値を利用する。falseなら利用しない</td>
        </tr>

    </table>

</div>


<h3>INTERMediator_DBAdapter.db_update(args)　データベースのレコードの更新</h3>

<div class="table">

    <table>

        <tr>
            <th>属性</th>
            <th>指定する値</th>
        </tr>

        <tr>
            <td>name</td>
            <td>定義ファイルのIM_Entry関数の第1引数に指定する配列のname属性の値</td>
        </tr>

        <tr>
            <td>conditions</td>
            <td>{field:xx, operator:xx, value:xx} の形式のオブジェクトの配列。検索条件をANDで追加する</td>
        </tr>

        <tr>
            <td>dataset</td>
            <td>{field:xx, value:xx}の形式のオブジェクトの配列。設定するフィールドとその値を指定する</td>
        </tr>

    </table>

</div>


<h3>INTERMediator_DBAdapter.db_delete(args)　データベースのレコード削除</h3>

<div class="table">

    <table>

        <tr>
            <th>属性</th>
            <th>指定する値</th>
        </tr>

        <tr>
            <td>name</td>
            <td>定義ファイルのIM_Entry関数の第1引数に指定する配列のname属性の値</td>
        </tr>

        <tr>
            <td>conditions</td>
            <td>{field:xx, operator:xx, value:xx} の形式のオブジェクトの配列。検索条件をANDで追加する</td>
        </tr>

    </table>

</div>


<h3>INTERMediator_DBAdapter.db_createRecord(args)　データベースに新しいレコードを作成する</h3>

<p>関数の返り値は、作成したレコードのキーフィールドの値です。</p>

<div class="table">

    <table>

        <tr>
            <th>属性</th>
            <th>指定する値</th>
        </tr>

        <tr>
            <td>name</td>
            <td>定義ファイルのIM_Entry関数の第1引数に指定する配列のname属性の値</td>
        </tr>

        <tr>
            <td>dataset</td>
            <td>{field:xx, value:xx} の形式のオブジェクトの配列。新しいレコードに対して指定フィールドに値を設定する</td>
        </tr>

    </table>

</div>
<p>なお、認証を必要とする状況では、別途メソッドが用意されています。db_query(args) に対しては、db_queryWithAuth(args.complation)
    という関数になります。argはdb_queryと同じですが、complationには認証が成功した後に実行されるプログラムを関数リテラルの形式で与えておくことができます。</p>

<h2>データコンバータクラスの利用方法</h2>

<p>
    IM_Entry関数の第2引数で、'formatter'を利用して、特定のコンテキストのフィールドに対して、データベースの読み書き前後にフィルタを設定することができます。このときに使うクラスをデータコンバータクラスと呼びます。自分で作成もできますが、以下のものが最初から組み込まれています。自分で作成する場合はDataConverter_template.phpを参照してください</p>

<div class="table">
    <table>
        <tr>
            <th>DataConverter_AppendPrefix.php</th>
            <th>parameterに指定した文字列を前につける</th>
        </tr>
        <tr>
            <td>DataConverter_AppendSuffix.php</td>
            <td>parameterに指定した文字列を後につける</td>
        </tr>
        <tr>
            <td>DataConverter_Currency.php</td>
            <td>parameterに指定した小数以下の桁数で、数値を通貨で表示する</td>
        </tr>
        <tr>
            <td>DataConverter_FMDateTime.php</td>
            <td>FileMaker Serverの出力する「月/日/年」形式の日付や時刻を整える</td>
        </tr>
        <tr>
            <td>DataConverter_HTMLString.php</td>
            <td>改行をBRタグ要素、そして＜や＞や＆を参照形式に変換する。データベースへの書き込み時はそのままの文字列</td>
        </tr>
        <tr>
            <td>DataConverter_MySQLDateTime.php</td>
            <td>MySQLの出力する「年-月-日」形式の日付や時刻を整える</td>
        </tr>
        <tr>
            <td>DataConverter_Number.php</td>
            <td>arameterに指定した小数以下の桁数で、数値をカンマ付きで表示する</td>
        </tr>
        <tr>
            <td>DataConverter_NumberBase.php</td>
            <td>NumberやCurrencyの基底クラス</td>
        </tr>
        <tr>
            <td>DataConverter_template.php</td>
            <td>データコンバータのクラスのテンプレート</td>
        </tr>
    </table>
</div>
<h2>データベースクラスを自作する</h2>

<p>
    データベースクラスを独自に作成する場合には、以下のようなPHPのクラスが基本となります。もちろん、データベースクラスを1から作れるのですが、たぶん、そういうニーズはまずないと思います。データベースをPDOで使うならINTER-MediatorのDB_PDO.php、FileMaer
    Serverを使うならDB_FileMaker_FX.phpを拡張したクラスを定義します。基底クラスの方のファイルも読み込みが必要です。以下の例は、INTER-Mediatorフォルダと同じフォルダに、このデータベースクラスのファイルがあるというわけです。自分が作るクラスでも、最初にDBをつけないといけません。IM_Entry関数の引数などでの設定は、この場合DB_をのぞいた「MyOriginalDB」を指定します。</p>


<div class="code">


   <pre><code>require_once( "INTER-Mediator/DB_PDO.php" );


       class DB_MyOriginalDB extends DB_PDO.php {


       function getFromDB($dataSourceName) {

       /*
       ここにプログラムを追加できる
       */

       $result = super::getFromDB($dataSourceName);

       /*
       ここにプログラムを追加できる
       */

       $this->mainTableCount = count( $result ); //レコード数

       return $result;
       }

       function setToDB($dataSourceName) {

       /*
       ここにプログラムを追加できる
       */

       super::setToDB($dataSourceName);

       /*
       ここにプログラムを追加できる
       */

       }

       function newToDB($dataSourceName) {

       /*
       ここにプログラムを追加できる
       */

       $lastKeyValue = super::newToDB($dataSourceName);

       /*
       ここにプログラムを追加できる
       */

       return $lastKeyValue;

       }

       function deleteFromDB($dataSourceName) {

       /*
       ここにプログラムを追加できる
       */

       $result = super::deleteFromDB($dataSourceName)
       ;
       /*
       ここにプログラムを追加できる
       */

       }

       }</code></pre>


</div>


<p>
    自分で作るクラスでは、要はCRUDに対応した4つのメソッドをオーバーライドすることによって、独自の仕組みを組み込むことができます。また、4つのうち、特にプログラムの追加がない場合には、定義する必要はありません。いずれの関数も、コンテキスト名を引数に取ります。そして、現在処理しているコンテキスト名が設定されてこれらのメソッドを呼び出します。</p>


<p>
    getFromDBメソッドは、データベースからデータを取り出します。取り出し結果は連想配列の配列です。連想配列のキーがフィールド名になっています。そこから、特定のフィールドの値を元に集計をしたり、あるいは必要な値だけに取り除くなどの処理を、親クラスのgetFromDBメソッドを呼び出す後に入れればいいでしょう。リクエスト時と同じフィールド名を返す必要はなく（つまりINTER-Mediatorはそのチェックをしていない）、自由に連想配列の配列を作ります。そして、ページファイルの方で適切なフィールド名を指定すれば、集計結果が表示されます。なお、ページファイルで、一定レコード数ごとのページングをしているときには、mainTableCountメンバ変数にレコード数、つまり返す配列の要素数も指定します。何か問題が発生したのなら、array()
    を返します。以下のプログラムは売り上げのテーブルから集計を行う例です。</p>


<div class="code">


   <pre><code>$result = super::getFromDB($dataSourceName);

       if ( $dataSourceName == 'ItemsInvoice' ) {

       $summary = array();

       foreach( $returnValue as $record ) {

       $summary[ $record[ 'itemNo' ]] += $record[ 'qty' ] * $record[ 'unitPrice' ];

       }

       return array( $summary );

       }</code></pre>


</div>


<p>
    getFromDBメソッドを呼び出す前は、検索条件の追加なども可能です。たとえば、IM_Entry関数の第一引数に指定している配列が、$this->dataSourceで得られます。また、現在のコンテキストが$this->dataSourceで得られる配列の何番目かが$this->getIndexOfDataSource($dataSourceName)で得られます。例えば特定の名前のフィールドがあれば、それをFileMaker
    Serverのグローバルフィールドに設定して、検索条件から取り除くといったことも行えます。</p>


<div class="code">


    <pre><code>$this->dataSource[ $this->getIndexOfDataSource($dataSourceName) ][ 'global' ] = array( ...
        );</code></pre>


</div>


<p>setToDBとdeleteFromDBメソッドは、いずれも値の更新や削除のときに呼び出されるメソッドです。返り値は論理値で、処理が成功すればtrueで失敗ならfalseです。</p>


<p>newToDBは新規レコードの作成です。メソッドの返り値は、新たに作ったレコードのキーフィールドの値である必要があります。問題があれば返り値をfalseにします。</p>


<h3>データベースクラス内で便利なメソッド</h3>


<p>現状、未整理です。DB_Base.phpに多くは定義されています。以下は抜粋です。</p>


<div class="table">


    <table>


        <tr>
            <th>メンバ変数／メソッド</th>
            <th>役割</th>
        </tr>


        <tr>
            <td>$this->dataSource</td>
            <td>IM_Entry関数の第1引数の配列</td>
        </tr>


        <tr>
            <td>$this->currentUser</td>
            <td>ログインしたユーザ名</td>
        </tr>


        <tr>
            <td>$this->setDebugMessage($str)</td>
            <td>デバッグメッセージに追加する</td>
        </tr>


        <tr>
            <td>$this->setErrorMessage($str)</td>
            <td>エラーメッセージに追加する</td>
        </tr>


        <tr>
            <td>$this->setExtraCriteria($field, $operator, $value)</td>
            <td>検索条件の追加</td>
        </tr>


        <tr>
            <td>$this->setExtraSortKey($field, $direction)</td>
            <td>ソート条件の追加</td>
        </tr>


    </table>


</div>
<h2>データベースアクセス処理の拡張クラスを定義する</h2>

<p>
    データベース側の処理に割り込むには「データベースクラスを自作する」で説明する手法（「データアクセスクラスのサブクラスを利用する方法」と定義します）とここで説明する手法（「拡張処理クラスを定義する方法」とします）の2通りがあります。「データアクセスクラスのサブクラスを利用する方法」だと、すべてのコンテキストに対する処理を記述しなければなりません。言い換えれば、複数あるコンテキストの１つだけに対して処理を加えたい場合、そのコンテキストのときだけプログラムが実行されるようにする必要があります。コンテキストが増減したときのメンテナンスタスクが増えます。「拡張処理クラスを定義する方法」だと、特定のコンテキストにだけ利用されるクラスを指定するので、「コンテキストごとに分岐させる」処理は不要です。</p>

<p>
    IM_Entry関数の第一引数、つまりコンテキストの中に「extending-class」でクラス名を指定します。ここで指定したクラス名は任意のものでかまいませんが、そのクラスをPHPが認識できる場所に記述しておく必要があります。クラスは以下のようなインタフェースをインプリメントする必要があります。つまり、CRUDに対応する4種類のデータアクセス処理の前後にメソッドを含めることができるのです。</p>

<div class="code">
<pre><code>interface Extending_Interface_BeforeGet {
    function doBeforeGetFromDB($dataSourceName);
    }
    interface Extending_Interface_AfterGet {
    function doAfterGetFromDB($dataSourceName, $result);
    // function countQueryResult($dataSourceName);
    }
    interface Extending_Interface_BeforeSet {
    function doBeforeSetToDB($dataSourceName);
    }
    interface Extending_Interface_AfterSet {
    function doAfterSetToDB($dataSourceName, $result);
    }
    interface Extending_Interface_BeforeNew {
    function doBeforeNewToDB($dataSourceName);
    }
    interface Extending_Interface_AfterNew {
    function doAfterNewToDB($dataSourceName, $result);
    }
    interface Extending_Interface_BeforeDelete {
    function doBeforeDeleteFromDB($dataSourceName);
    }
    interface Extending_Interface_AfterDelete {
    function doAfterDeleteFromDB($dataSourceName, $result);
    }</code></pre>
</div>

<p>
    以下は、データベースからレコードを取得した後に呼び出されるクラスの定義例です。MyProgramというクラス名は任意ですが、2つのメソッドはインタフェースに決められたものを定義します。doAfterGetFromDBはデータベースからデータを取得した後に呼び出されます。引数$resultにはデータベースからの取得した結果が、連想配列の配列の形式で入っています。1レコードがフィールド名をキーとした連想配列になっており、レコードの数だけその配列があります。たとえば集計処理などを行い、同様に連想配列の配列にして結果を返します。このとき、ナビゲーションを使ってページ送りの処理をしているのなら、「レコードの個数」をcountQueryResultメソッドで返す必要があります。ナビゲーションがない場合にはこのメソッドの実装は不要です。また、ナビゲーションを使う場合でも、レコード総数がdoAfterGetFromDBの処理の後でも変わらないのであれば、countQueryResultメソッドは不要です。PHPではoptionのメソッドの定義をインタフェースできないので、定義上はコメントでこのメソッドを記載しています。</p>

<div class="code">
<pre><code>class MyProgram implements Extending_Interface_AfterGet
    {
    function doAfterGetFromDB($dataSourceName, $result) {
    foreach( $result as $record ) {
    foreach( $record as $field =&gt; $value ) {
    :
    }
    }
    $return result;
    }
    }</code></pre>
</div>

<p>
    countQueryResultメソッドを記述する場合の例を以下に示します。countQueryResultはdoAfterGetFromDBよりも後に呼び出されます。countQueryResultによって返されるのは、実際のレコード数ではなく、検索条件に合ったレコード数です。つまり、1万個のレコードのうち40個を表示している場合には、1万という数値を返す必要があります。doAfterGetFromDBで集計処理などをすると、1万レコードを取得して、それが20個などになると思います。その場合は20個を返さないといけません。この場合、自分でメンバ変数（dataCount）を定義して、そこに値を残しておくのが分かりやすい方法でしょう。</p>

<div class="code">
<pre><code>class MyProgram implements Extending_Interface_AfterGet
    {
    var $dataCount;
    function doAfterGetFromDB($dataSourceName, $result) {
    :
    $thisthis-&gt;dataCount = count( $result );
    $return result;
    }
    function countQueryResult($dataSourceName) {
    $return $thisthis-&gt;dataCount;
    }
    }</code></pre>
</div>

<p>
    それぞれのメソッドの$dataSourceNameはコンテキスト名の文字列が入っています。2つのコンテキストでクラスを共有するような場合には分岐のための手がかりになります。doAfterNewToDBの2つ目の引数$resultは、新たに作成したレコードのキーフィールドの値が設定されています。この値はdoAfterNewToDBメソッドでの返り値にしなければなりません。doAfterDeleteFromDBとdoAfterSetToDBメソッドの2つ目の引数はデータベース処理が失敗したかどうかをbooleanで示され、trueなら処理が成功です。これらのメソッドでもやはり引数で得られた値を返さないといけません。</p>

<p>開発者が作成するクラスで「DB_UseSharedObjects」クラスの子クラスにした場合は、他のオブジェクトへの参照が得られます。メソッドが呼び出された段階で、メンバ変数はオブジェクトを参照した状態になります。</p>


<div class="table">
    <div class="caption">DB_UseSharedObjectsを継承したときに利用できるメンバ変数</div>
    <table>
        <tr>
            <th>メンバ変数</th>
            <th>参照するもの</th>
        </tr>
        <tr>
            <td>$this-&gt;dbSettings</td>
            <td>DB_Settingsクラスのインスタンス</td>
        </tr>
        <tr>
            <td>$this-&gt;logger</td>
            <td>DB_Loggerクラスのインスタンス</td>
        </tr>
        <tr>
            <td>$this-&gt;authCommon</td>
            <td>DB_AuthCommonクラスのインスタンス</td>
        </tr>
        <tr>
            <td>$this-&gt;formatter</td>
            <td>DB_Formattersクラスのインスタンス</td>
        </tr>
    </table>
</div>

<h2>ユーザ認証とアクセス権の動作について</h2>

<p>ユーザ認証とアクセス権の設定をサポートします。</p>


<p>
    ユーザ認証ではセキュリティを高めるために、サーバからクライアントに「チャレンジ」を送り、その値を利用して認証情報を作ります。そのため、サーバ側にチャレンジを残しておく必要があり、テーブルの定義が必要です。そのテーブルは、IM_Entryの第3引数あるいはparams.phpで指定したユーザで読み書きの権限が必要です。チャレンジのテーブル名は、IM_Entryの第2引数で指定するか、あるいは既定値の名前（issuedhash）のテーブルを作成します。テーブルには以下のフィールドが必要です。</p>


<div class="table">


    <div class="caption">チャレンジのテーブルに必要なフィールド</div>


    <table>


        <tr>
            <th>フィールド名</th>
            <th>型の例</th>
            <th>説明</th>
        </tr>


        <tr>
            <td>user_id</td>
            <td>INT,</td>
            <td>ユーザテーブルのキーフィールドとなるid値（ユーザをデータベース内のテーブルで管理する場合に利用）</td>
        </tr>


        <tr>
            <td>username</td>
            <td>VARCHAR(48),</td>
            <td>ユーザテーブルのキーフィールドとなるid値（ユーザをデータベースエンジンが提供するもので運用する場合に利用）</td>
        </tr>


        <tr>
            <td>clienthost</td>
            <td>VARCHAR(48),</td>
            <td>クライアントを識別するもの。Ver.1.0.5の実装では、クライアントのIPアドレスのみを記録している</td>
        </tr>


        <tr>
            <td>hash</td>
            <td>VARCHAR(48),</td>
            <td>チャレンジに使うハッシュ値。実際には24バイトの16進数文字列。</td>
        </tr>


        <tr>
            <td>expired</td>
            <td>DateTime,</td>
            <td>チャレンジの有効期限を示すタイムスタンプ値</td>
        </tr>


    </table>


</div>


<p>
    なお、このテーブルへの検索では、user_idとclienthostあるいはusernameとclienthostの2つのフィールドに対してAND演算での検索条件が与えられます。従って、高速化するためには、この2つのフィールドを合成したインデックスを作っておくなどの措置をとる事ができます。</p>


<p>
    認証のためのユーザは、データベース内にテーブルを作成する方法と、データベースエンジンが管理するユーザによる方法を利用できます。データベース内にテーブルを作る場合、そのテーブルは、IM_Entryの第3引数あるいはparams.phpで指定したユーザで少なくとも読み出しの権限が必要です。チャレンジのテーブル名は、IM_Entryの第2引数で指定するか、あるいは既定値の名前（authuser）のテーブルを作成します。テーブルには以下のフィールドが必要です。</p>


<div class="table">


    <div class="caption">ユーザテーブルに必要なフィールド</div>


    <table>


        <tr>
            <th>フィールド名</th>
            <th>型の例</th>
            <th>説明</th>
        </tr>


        <tr>
            <td>id</td>
            <td>INT AUTO_INCREMENT,</td>
            <td>連番の数値を入れて、キーフィールドとする</td>
        </tr>


        <tr>
            <td>username</td>
            <td>VARCHAR(48),</td>
            <td>ユーザ名（特に制限はないが、重複した名前が定義されないようにするのが望ましい）</td>
        </tr>


        <tr>
            <td>hashedpasswd</td>
            <td>VARCHAR(48),</td>
            <td>パスワードのハッシュ値</td>
        </tr>


    </table>


</div>


<p>
    ユーザの場合は、ユーザ名をキーフィールドに使えるとも考えられますが、大量のユーザになったときなどに処理速度を有利にするために、内部的には連番で与えた数値で処理をすることにします。なお、usernameを条件として検索をかけるので、高速化のためにはこのフィールドにインデックスを作成しておきます。パスワードはハッシュを保存しますが、ハッシュ値は、次の手順で計算をします。</p>


<ol>


    <li>パスワード（pw）と、4バイトのソルト（s）を用意します。</li>


    <li>パスワードとソルトをつなげた文字列のSHA-1を求めます（ sha1(pw+s) → H1）</li>


    <li>H1の16進数表現した文字列と、ソルトを16進数表現した文字列をつなげます（hex(H1)+hex(s)→H2）</li>


    <li>H2をフィールドに保存します。</li>


</ol>


<p>たとえば、Mac OS
    Xだと、pw=user1、s=TESTとすると、以下のコマンドで「d83eefa0a9bd7190c94e7911688503737a99db0154455354」というハッシュ値の16進数表現を求めることができます。</p>


<div class="code">


   <pre><code>pw=user1

       salt=TEST

       h1=`/bin/echo -n "${pw}${salt}" | openssl sha1 -sha1`

       h2=`echo -n "${salt}" | xxd -ps`

       echo ${h1}${h2}</code></pre>


</div>


<div class="table">


    <div class="caption">グループテーブル（既定名：authgroup）のフィールド</div>


    <table>


        <tr>
            <th>フィールド名</th>
            <th>型の例</th>
            <th>説明</th>
        </tr>


        <tr>
            <td>id</td>
            <td>INT AUTO_INCREMENT,</td>
            <td>グループを識別するための番号</td>
        </tr>


        <tr>
            <td>groupname</td>
            <td>VARCHAR(48),</td>
            <td>グループ名</td>
        </tr>


    </table>


</div>


<div class="table">


    <div class="caption">ユーザ・グループ対応付けテーブル（既定名：authcor）のフィールド</div>


    <table>


        <tr>
            <th>フィールド名</th>
            <th>型の例</th>
            <th>説明</th>
        </tr>


        <tr>
            <td>user_id</td>
            <td>INT,</td>
            <td>所属するユーザのidフィールドの値</td>
        </tr>


        <tr>
            <td>group_id</td>
            <td>INT,</td>
            <td>所属するグループのidフィールドの値</td>
        </tr>


        <tr>
            <td>dest_group_id</td>
            <td>INT,</td>
            <td>所属されるグループのidフィールドの値</td>
        </tr>


    </table>


</div>


<h3>アクセス権に関する設定の評価</h3>


<p>
    認証の設定は基本的にコンテキストに行いますが、IM_Entryの2番目の引数にも行えます。つまり、2カ所の設定があるので、以下のように、コンテキストに設定する方を「コンテキストの認証設定」、2つ目の引数に設定するのを「オプションの認証設定」とします。また、いずれも、アクセス権の設定も行いますが、「認証とアクセス権」を合わせてここでは「認証」というネーミングをします。</p>


<div class="code">


   <pre><code>IM_Entry(

       array(
       array( "name"=>"context"

       "authentication"=>array(
       /* コンテキストの認証設定 */
       )
       )
       ),

       array(
       "authentication"=>array(
       /* オプションの認証設定 */
       ),
       ....);</code></pre>


</div>


<h4>コンテキストの認証設定なし、オプションの認証設定あり</h4>


<p>タイトル用な条件だと、コンテキストの認証設定のuserとgroupがアクセス権の設定に関係します。もし、userもgroupも設定されていない場合は、認証が通ったユーザは何でもできると考えてください。</p>


<p>userあるいはgroupが設定されている場合、認証が通ると同時に、そのユーザあるいはそのユーザを含むグループが、userあるいはgroupの設定に含まれている必要があります。</p>


<h4>コンテキストの認証設定あり、オプションの認証設定なし</h4>


<p>オプションの設定のうちuserとgroupの設定がないということです。この場合、特定のコンテキストのデータベース処理に対して、コンテキストの認証設定が適用されます。</p>


<h4>コンテキストの認証設定あり、オプションの認証設定あり</h4>


<p>両方の認証設定があれば、先にオプションの認証設定が評価されて、その後にコンテキストの認証設定が評価されます。</p>


<h4>コンテキストの認証設定の適用対象</h4>


<p>適用対象として、4つのデータベース処理、load/update/new/deleteに対する処理と、それらすべてに対してまとめて設定を行うallがあります。</p>


<h4>コンテキストの認証設定のtableとfleld</h4>


<p>
    "table"キーに対する値がfield-userあるいはfield-groupの場合は、そのテーブルにあるfieldに指定したフィールドに、ログインが成功したユーザあるいはそのユーザが含むグループの名前が設定されちているレコードだけに絞り込まれます。検索条件にANDでユーザないしはグループの値をfieldに指定したフィールドに対する条件を付け加えます。したがって、fieldで指定したフィールドのうち、空欄ものは認証すればいっさいアクセスできないということになります。</p>


<p>
    "table"キーに対する値がfield-useやfield-groupではない場合、アクセス権はすべてのテーブルに渡って適用されます。レコードごとのアクセス権を記録するフィールドは不要です。このとき、userあるいはgroup属性に含まれていないユーザで認証した場合、いっさいのアクセスはできないようになっています。オプションの認証設定と異なる動作ですので、注意してください。</p>


<p>
    load/update/deleteに関しては、アクセス権は「検索条件」として集約されます。一方、newの操作に対しては、アクセス権がある場合だけ、レコードの作成が可能です。レコードの作成により、fieldで指定したフィールドに、ユーザないしはグループが設定されます。ユーザの場合は1つに決まりますが、グループの場合は、グループ名を並べ替えたときのいちばん先頭のグループ名を記録するようにします。</p>
</div>
</body>
</html>